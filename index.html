<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy of Love - Brenda</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; 
            touch-action: none;
        }
        #ui {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 0 0 15px rgba(255,100,200,0.8);
            z-index: 10;
            transition: opacity 1s;
        }
        p { font-size: 1.4rem; opacity: 0.9; margin-top: 10px; letter-spacing: 2px; font-weight: 300; }
        
        #hint {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #ff0066;
            font-size: 0.9rem;
            opacity: 0.6;
            z-index: 20;
            letter-spacing: 1px;
            animation: pulse 2s infinite;
        }

        #carta {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; visibility: hidden; transition: all 1.5s ease;
            z-index: 100; color: white; text-align: center; padding: 25px; box-sizing: border-box;
        }
        #carta.visible { opacity: 1; visibility: visible; }
        #foto-carta { width: 240px; border-radius: 15px; border: 2px solid #ff0066; margin-bottom: 20px; box-shadow: 0 0 25px #ff0066; }
        #texto-carta { max-width: 500px; font-size: 1.2rem; line-height: 1.6; font-style: italic; color: #ffe6f0; }
        #btn-volver { margin-top: 30px; padding: 10px 25px; background: none; border: 1px solid white; color: white; border-radius: 25px; cursor: pointer; font-size: 0.9rem; }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }
    </style>
</head>
<body>

    <div id="hint">Busca la estrella que brilla m√°s... </div>

    <div id="ui">
        <p>Te amo 3 millones</p>
    </div>

    <div id="carta">
        <img id="foto-carta" src="https://files.catbox.moe/uv36z0.jpg">
        <div id="texto-carta">
            Esto que sientes, es lo que yo siento cada vez que estoy contigo <br>
            No puedo darte una sortija, no tengo nada que dar solo mi amor <br>
            Tal vez no sea la mejor persona del mundo Brenda <br>
            pero te juro con todo mi coraz√≥n que jamas jamas dejar√© de amarte
        </div>
        <button id="btn-volver" onclick="document.getElementById('carta').classList.remove('visible'); document.getElementById('ui').style.opacity='1';">Volver al universo</button>
    </div>

    <audio id="musica" loop>
        <source src="https://files.catbox.moe/108g57.mp3" type="audio/mpeg">
    </audio>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const audio = document.getElementById('musica');
        const hint = document.getElementById('hint');
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const heartGroup = new THREE.Group();
        scene.add(heartGroup);

        const particlesGeometry = new THREE.BufferGeometry();
        const count = 3000;
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        for(let i = 0; i < count * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 12;
            colors[i] = Math.random();
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const backgroundGalaxy = new THREE.Points(particlesGeometry, new THREE.PointsMaterial({
            size: 0.05, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending
        }));
        scene.add(backgroundGalaxy);

        const heartPoints = [];
        for (let i = 0; i < 6000; i++) {
            const t = Math.random() * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const z = (Math.random() - 0.5) * 6;
            heartPoints.push(new THREE.Vector3(x * 0.15, y * 0.15, z * 0.15));
        }
        const heart = new THREE.Points(new THREE.BufferGeometry().setFromPoints(heartPoints), new THREE.PointsMaterial({
            color: 0xff0066, size: 0.05, transparent: true, blending: THREE.AdditiveBlending
        }));
        heartGroup.add(heart);

        const starMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 24, 24),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        starMesh.position.set(2.5, 2.5, 0); 
        heartGroup.add(starMesh);

        function create3DName(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 256;
            ctx.fillStyle = 'white';
            ctx.font = 'Bold 90px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#ff0066';
            ctx.shadowBlur = 35;
            ctx.fillText(text, 256, 128);
            const texture = new THREE.CanvasTexture(canvas);
            const geometry = new THREE.BoxGeometry(2.5, 1.2, 0.3);
            const matNombre = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const matAura = new THREE.MeshBasicMaterial({ color: 0xff0066, transparent: true, opacity: 0.4 });
            return new THREE.Mesh(geometry, [matAura, matAura, matAura, matAura, matNombre, matNombre]);
        }
        const name3D = create3DName("BRENDA");
        heartGroup.add(name3D);

        const emojiList = ['üòç','üíì','üòö','ü•∞'];
        const emojiSprites = [];
        for (let i = 0; i < 15; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            context.font = '80px serif'; context.textAlign = 'center'; context.textBaseline = 'middle';
            context.fillText(emojiList[i % emojiList.length], 64, 64);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            const radius = 2.5 + Math.random() * 1.5;
            const angle = (i / 15) * Math.PI * 2;
            sprite.position.set(Math.cos(angle) * radius, (Math.random() - 0.5) * 3, Math.sin(angle) * radius);
            sprite.scale.set(0.6, 0.6, 0.6);
            sprite.userData = { angle: angle, radius: radius, speed: 0.01 + Math.random() * 0.01 };
            emojiSprites.push(sprite);
            heartGroup.add(sprite);
        }

        camera.position.z = 8;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false, px = 0, py = 0;

        const handleInteraction = (clientX, clientY, isClick) => {
            if (audio.paused) { audio.play().catch(() => {}); hint.style.opacity = '0'; }
            
            if (isClick) {
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(starMesh);
                if (intersects.length > 0) {
                    document.getElementById('carta').classList.add('visible');
                    document.getElementById('ui').style.opacity = '0';
                    return;
                }
            }

            if (isDragging) {
                heartGroup.rotation.y += (clientX - px) * 0.01;
                heartGroup.rotation.x += (clientY - py) * 0.01;
            }
            px = clientX; py = clientY;
        };

        window.addEventListener('mousedown', (e) => { isDragging = true; handleInteraction(e.clientX, e.clientY, true); });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', (e) => handleInteraction(e.clientX, e.clientY, false));
        
        window.addEventListener('touchstart', (e) => { 
            isDragging = true; 
            px = e.touches[0].clientX; py = e.touches[0].clientY;
            handleInteraction(px, py, true);
        });
        window.addEventListener('touchend', () => isDragging = false);
        window.addEventListener('touchmove', (e) => handleInteraction(e.touches[0].clientX, e.touches[0].clientY, false));

        function animate() {
            requestAnimationFrame(animate);
            backgroundGalaxy.rotation.y += 0.001;
            if (!isDragging) heartGroup.rotation.y += 0.004;

            emojiSprites.forEach(sprite => {
                sprite.userData.angle += sprite.userData.speed;
                sprite.position.x = Math.cos(sprite.userData.angle) * sprite.userData.radius;
                sprite.position.z = Math.sin(sprite.userData.angle) * sprite.userData.radius;
            });

            const scale = 1 + Math.sin(Date.now() * 0.004) * 0.05;
            heart.scale.set(scale, scale, scale);
            name3D.scale.set(scale, scale, scale);
            starMesh.scale.set(scale * 1.3, scale * 1.3, scale * 1.3);
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

